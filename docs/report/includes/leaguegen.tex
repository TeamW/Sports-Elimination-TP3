\subsection{Design}
The necessity of having the ability to generate new leagues arose
after the algorithm was created. Prior to this point our oracle for
testing the algorithm was the information found inside the Wayne paper
\cite{Wayne} and the standard data the application will load with
(2011-2012 league information). The team agreed that this would not be 
enough to fully test the algorithm thus the league generation was
created. After further discussion it was agreed that this
functionality was to be added to the final desktop application for the
reasons as listed below:

\begin{itemize}
\item To increase the user experience of the application.
\item To enhance the testable functionality by supplying different data
sets.
\item To allow users interested in sports elimination calculations to
manipulate the generated file to further examine or create
elimination criteria.
\end{itemize}

The major design decision of the league generation functionality was to
generate a league in such a way that every team in the league,
regardless of division, will always play the same number of games. This
gives all teams an equal chance of finishing top their respective
divisions. Equality would be implied in a league where every division has
an equal number of teams but the real-world scenario is the six divisions
have a varying number of teams with one division having four teams, another
having six, and the rest having five.


% What bias? What preconditions? What...?
A team should not have a bias depending on the league it
plays in, and with our best efforts this should not occur in the
output of the generate functionality. Other
modules of the application depend on the league being in a very
specific format otherwise a completely new league with an equal number
of teams per league could be generated without having to care for
these preconditions. 

One necessity of the generate functionality was to generate a league
with a time scale that was roughly the same season length as a real
season. This would create a more realistic analysis for any user that
has already perused the standard data provided when the application
first starts.

The file created by the generate functionality must be in the same
format as the original league given to the application on start-up due
to the parser requiring a specific format and to utilise existing functionality inside the application.

\subsection{Implementation}
The total number of games picked for each team to play was computed to
be 180 games per team. This was not an arbitrary choice as each team
in the entire season must play the same number of games and the season
should be of a similar length to an actual season.

For each team to play the same number of games, the Least Common
Denominator (LCD) of the variant sizes of leagues must be found. The
variant sizes are 4, 5 and 6 and the LCD therefore is 60. This then
implies that any integer multiple greater than or equal to 1 of the
LCD will ensure that every team will play the same number of games
regardless of league. The actual number of games played by each team
in the league is 162 and the closest multiple of the LCD to 162 is 180.
The closest multiple is chosen with the intention of this resulting
in a season length similar to an actual season length. (It is left to
the readers contemplation as to why 162 games are picked for an real
division as 162 is neither equally divisible by four or five).
% Do we really want to say that?

Both the first and the second iteration of the generation
functionality follow the same game creation and scheduling pattern.

%% INSERT PSEUDOCODE HERE

A StringBuilder was used to hold the generated lines that will become
the new file - this was a decision for performance reasons due to the
line count being large enough that standard string concatenation would
be inefficient.

It was quickly noticed in the first iteration of the generate
functionality that the occurrences of non-trivially eliminated teams
were scarce in the entire league and it was often the case that no
eliminated teams were found. (Reference table to back up these
results? If this isn't actually the case then whoops) The strive to
create a fair league had inadvertently created one in which we could
not present the interesting results discovered by our application and
so it was decided to ``fix'' the results generated as to demonstrate
and further test the full capacity of the application.

Prior to the fixtures of a league being created, a HashMap of each
Team object in the league to an Integer value is created. As each Team
is added into the HashMap the Integer value is incremented from zero to
provide a unique identifier for each team.

% What is this integer value? Reads as if its the hash map value which
% it obviously isn't...
When the matches are being generated the integer value
associated with each Team in the match is added onto the respective
Teams score thus ``fixing'' the matches in such a way that a team that
would normally have lost a match may now win. 

This ``fixing'' of results now generates a league that frequently has
non-trivial eliminations far more often than none at all and it was
decided that this was a better choice for the generate functionality
as it improved the overall user experience of this segment of the
application. 