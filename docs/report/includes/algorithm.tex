\subsection{Introduction}

The Ford-Fulkerson is the algorithm central to the entire project. The
algorithm is used to determine the elimination of the teams within the
division. The final residual graph (described below) was also used in an
extension to the project to work out the certificate of elimination
(described below).

\subsection{Terminology}

\begin{description}

\item[Residual Graph]

\item[Residual Path]

\item[Breadth First Search]

\item[Backwards/Forwards Edges]

\item[Ford-Fulkerson Algorithm]

\item[Flow and Capacity] Each edge from one vertex to another has two values
called flow and capacity. These are normally integer values (as they are for 
this algorithm) although can be floating point values for some applications.
These can be mapped directly to the real-life application of water and pipes.
The pipe is like an edge that can move a certain amount of water, its capacity.
The current amount of water running through the pipe is known as the flow.

\item[Maximum Flow] The maximum flow of a network graph is the maximum flow
out from the source vertex into the sink vertex.

\item[Saturating Flow] If the maximum flow leaving the source matches the total
capacity of edges leaving the source means that the flow is classed as
saturating.

\item[Triviality of Elimination] A team can be classed as trivially or
non-trivially eliminated. A trivial elimination is when a team is known to be
eliminated either when the league has finished and they aren't at the top or
by using the same na\"{\i}ve calculation as sports pundits traditionally
use.

\item[Max Flow-Min Cut]

\item[Certificate Elimination] A certificate of elimination is the list of
teams responsible for eliminating the respective team. A certificate is
generated from the residual graph by using the max flow-min cut theorem
described above. The team vertices on the source side of the cut are the
teams responsible for the elimination. A certificate can only be found when
the team has been found to be non-trivially eliminated.

\end{description}

\subsection{Design}

Wayne paper~\cite{Wayne}

Kern paper~\cite{Kern}

Adler paper~\cite{Adler}

\subsubsection{Network Flow Graph}

The design of the algorithm is centred around a network flow graph of
team nodes and match nodes as described in the Wayne
paper~\cite{Wayne}. The graph is used to test the elimination status of a
$team_k$ by pushing flow from the source to the sink as will be described 
later. The graph has four specific kinds of vertices. There is a source
which only has outgoing edges, a sink which has only incoming edges, and
team and match vertices. There is a team vertex for every team in the
division that isn't $team_k$ and there is a match vertex for every pair
of teams in the list of team vertices.

The source vertex has an outgoing edge to each match vertex.
The capacity of these outgoing edges is the number of games remaining between
the two teams associated with the match, these teams will be denoted
$team_i$ and $team_j$.

Each match vertex has an outgoing edge to both $team_i$ and $team_j$ of an 
infinite capacity and an incoming edge from the source of capacity equal to the 
number of games remaining between $team_i$ and $team_j$.

Each team vertex has an incoming edge from their respective match vertices with
infinite capacity and an outgoing edge to the sink of capacity equal to the 
maximum number of points that $team_k$ can achieve if they win all their 
remaining games minus the number of wins the team belonging to the respective 
team vertex has. 

\subsubsection{Residual Graph}

The algorithm also creates many residual graphs throughout a single iteration,
these are used to see how much more flow can be pushed through the initial
network flow graph.

The residual graph has a similar structure to the network flow graph however
the distinctions between types of vertices aren't considered. The residual
graph creates forwards and backwards edges between each pair of vertices `a'
and `b' based on their edge's flow and capacity. A forwards edge is added from
`a' to `b' based on their edge's capacity minus the edge's flow. A backwards 
edge is added from `b' to `a' based on their edge's flow.


\subsubsection{Algorithm behaviour}

It was decided to store the elimination status of a team inside the
respective Team object so the algorithm will only be run if the team isn't
currently known to be eliminated. This is a decision for pure optimisation and 
is not part of the Ford-Fulkerson algorithm.

Two `short circuits' have been added prior to the algorithm for efficiency:
\begin{enumerate}
\item If $team_k$ has no remaining games and is not at the top of the league
then $team_k$ is trivially eliminated. This is the obvious elimination since
there is nothing else to play for.
\item If the difference between $team_k$'s current points and the league 
leader's current points is more than the number of remaining matches $team_k$ 
has to play then the $team_k$ is trivially eliminated. This means that no even 
if $team_k$ was to win every single match they would be unable to even be at 
the top of the league if all other teams somehow lost every single one of their 
matches. This is the na\"{\i}ve calculation that sports pundits regularly use 
to announce that a team has been eliminated from a sports league.
\end{enumerate}

It was decided that the algorithm should have a verbose flag to output
its computation every iteration - this was to help debugging and also
allow the reader to analyse the algorithm at various stages of its
cycle. 

\subsection{Implementation}

- Pseudocode



\begin{algorithm}[H]
  \SetAlgoLined
  \SetKwData{Graph}{graph} \SetKwData{V}{v} \SetKwData{Adj}{AdjListNode}
  \SetKwData{Edge}{edge} \SetKwData{Flow}{flow} \SetKwData{Source}{source}
  \SetKwData{Sink}{sink} \SetKwData{T}{$team_k$}
  \SetKwInOut{Input}{input} \SetKwInOut{Output}{output}
  \Input{A team \T whose elimination status is to be evaluated}
  \KwResult{A boolean value defining the elimination status of team \T}
  \Begin{
    
    
    \ForEach{Vertex in graph}{
      \ForEach{AdjListNode in Vertex}{
        Set flow of AdjListNode to zero
      }
    }
    Capacity of source 
  }
  \caption{THIS IS A CAPTIONN}
\end{algorithm}