\subsection{Introduction}

The Ford-Fulkerson is the algorithm central to the entire project. The
algorithm is used to determine the elimination of the teams within the
division. The final residual graph (described below) was also used in an
extension to the project to work out the certificate of elimination
(described below).

\subsection{Terminology}

\begin{description}

\item[Breadth First Search] (known as BFS). This is an algorithm which will
traverse a graph starting from a given vertex, visiting each of its
adjacent vertices, then repeating this process for each of the adjacent
vertices until all vertices have been visited. BFS can sometimes be described
as travelling along a graph by `fanning out' along the vertices.

\item[Ford-Fulkerson Algorithm] The Ford-Fulkerson algorithm calculates the
maximum flow from the source to the sink in a network flow graph using residual 
graphs and augmenting paths.

\item[Flow and Capacity] Each edge from one vertex to another has two values
called flow and capacity. These are normally integer values (as they are for 
this algorithm) although can be floating point values for some applications.
These can be mapped directly to the real-life application of water and pipes.
The pipe is like an edge that can move a certain amount of water, its capacity.
The current amount of water running through the pipe is known as the flow.

\item[Maximum Flow] The maximum flow of a network graph is the maximum flow
out from the source vertex into the sink vertex.

\item[Backwards/Forwards Edges] These backwards and forwards edges are
created from a network flow graph and are used to create a residual graph. A
forwards edge is an edge from $vertex_i$ to $vertex_j$ that matches the
amount of flow that can be pushed from $vertex_i$ to $vertex_j$ to
saturate the flow to capacity. A backwards edge is an edge from $vertex_j$
to $vertex_i$ that matches the amount of flow going from $vertex_i$ to
$vertex_j$.

\item[Saturating Flow] If the maximum flow leaving the source matches the total
capacity of edges leaving the source then the flow in the graph is classed as
saturating.

\item[Residual Graph] This graph is created from the network flow graph. It
contains backwards and forwards edges calculated from the network flow
graph.

\item[Residual Path] A residual path is a path in the residual graph from
the source to the sink. The minimum capacity of all edges in the residual
path equates to the amount of extra flow that can be passed through the
network graph by manipulating the flow down the edges in the network graph in 
one of two ways: increasing the value of flow on the edge in the network graph 
by the minimum capacity if it is a forward edge and reducing the value of flow
on the edge in the network graph if it is a backwards edge.

\item[Triviality of Elimination] A team can be classed as trivially or
non-trivially eliminated. A trivial elimination is when a team is known to be
eliminated either when the league has finished and they aren't at the top or
by using the same na\"{\i}ve calculation as sports pundits traditionally
use.

\item[Max Flow-Min Cut] The Max Flow-Min Cut theorem states that in a network
flow graph, the maximum amount of flow from the source to the sink is equal
to the minimum capacity that, when removed from the network graph, will
cause a bottleneck such that nothing can flow from the source to the sink.

\item[Certificate Elimination] A certificate of elimination is the list of
teams responsible for eliminating the respective team. A certificate is
generated from the residual graph by using the max flow-min cut theorem
described above. The team vertices on the source side of the cut are the
teams responsible for the elimination. A certificate can only be found when
the team has been found to be non-trivially eliminated.

\end{description}

\subsection{Design}

\subsubsection{Network Flow Graph}

The design of the algorithm is centred around a network flow graph of
team nodes and match nodes as described in the Wayne
paper~\cite{Wayne}. The graph is used to test the elimination status of a
$team_k$ by pushing flow from the source to the sink. The graph has four 
specific kinds of vertices: a source which only has outgoing edges, 
a sink which has only incoming edges, a team vertex for every team in the
division that isn't $team_k$ and a match vertex for every pair
of teams in the list of team vertices.

The source vertex has an outgoing edge to each match vertex.
The capacity of these outgoing edges is the number of games remaining between
the two teams associated with the match, denoted $team_i$ and $team_j$.

Each match vertex has an outgoing edge to both $team_i$ and $team_j$ of an 
infinite capacity and an incoming edge from the source.

Each team vertex has an incoming edge from their respective match vertices and 
an outgoing edge to the sink of capacity equal to the maximum number of points 
that $team_k$ can achieve if they win all their remaining games minus the 
number of wins the team belonging to the respective team vertex has. 

\subsubsection{Residual Graph}

The algorithm also creates many residual graphs throughout a single iteration,
these are used to see how much more flow, if any, can be pushed through the initial
network flow graph.

The residual graph has a similar structure to the network flow graph however
the distinctions between types of vertices aren't considered. The residual
graph creates forwards and backwards edges between each pair of vertices `a'
and `b' based on their edge's flow and capacity. A forwards edge is added from
`a' to `b' based on their edge's capacity minus the edge's flow. A backwards 
edge is added from `b' to `a' based on their edge's flow.


\subsubsection{Algorithm behaviour}

It was decided to store the elimination status of a team inside the
respective Team object so the algorithm will only be run if the team isn't
currently known to be eliminated. This is a decision for pure optimisation and 
is not part of the Ford-Fulkerson algorithm.

Two `short circuits' have been added prior to the algorithm for efficiency:
\begin{enumerate}
\item If $team_k$ has no remaining games and is not at the top of the league
then $team_k$ is trivially eliminated. This is the obvious elimination since
at this stage there remain no games for $team_k$ to play and hence no possible
way for $team_k$ to increase their score.
\item If the difference between $team_k$'s current points and the league 
leader's current points is more than the number of remaining matches $team_k$ 
has to play then the $team_k$ is trivially eliminated. In this scenario the best 
outcome of games for $team_k$ is to win all the remaining matches it has and for 
the current league leader to lose all their remaining games, however this will
still not allow $team_k$ to finish above the current league leader as they
physically do not have enough games remaining to overtake the current leader and 
hence $team_k$ is eliminated. This is the na\"{\i}ve calculation that sports 
pundits regularly use to announce that a team has been eliminated from a sports 
league.
\end{enumerate}

It was decided that the algorithm should have a verbose flag to output
its computation every iteration - this was to help debugging and also
allow the reader to analyse the algorithm at various stages of its
cycle. 

\subsection{Implementation}

- Pseudo-code

%
%
%\begin{algorithm}[H]
%  \SetAlgoLined
%  \SetKwData{Graph}{graph} \SetKwData{V}{v} \SetKwData{Adj}{AdjListNode}
%  \SetKwData{Edge}{edge} \SetKwData{Flow}{flow} \SetKwData{Source}{source}
%  \SetKwData{Sink}{sink} \SetKwData{TeamK}{$team_k$} \SetKwData{Flow}{flow}
%  \SetKwData{Path}{Residual Path}
%  \SetKwData{maxFlow}{maximumFlow} \SetKwData{capacity}{capacity}
%  \SetKwData{Cert}{certificateOfElimination}
%  \SetKwInOut{Input}{input} \SetKwInOut{Output}{output}
%  \Input{A team \TeamK whose elimination status is to be evaluated}
%  \KwResult{A boolean value representing the elimination status of team \TeamK}
%  \Begin{
%    Establish \Graph
%    \ForEach{\Edge in \Graph}{
%      Set flow of \Adj to zero
%    }
%    \maxFlow of \Graph\leftarrow\capacity of each \Edge from \Source 
%    \If{\TeamK is trivially eliminated}{\emph{return eliminated}}
%    \While{\exists a \Path through \Graph}{
%      \capacity\leftarrow-\capacity - \capacity of \Path
%      \For{\Edge in \Path}{
%        \If{\Edge is a Forward \Edge}{
%          \Flow of corresponding \Edge in \Graph\leftarrow increase by
%          \capacity of path
%        }
%        \Else{\Edge is a Backwards \Edge}{
%          \Flow of corresponding \Edge in \Graph\leftarrow decrease by
%          \capacity of \Path
%        }
%      }
%    }
%    \emph{Maximum \Flow has been achieved}
%    \If{\capacity is 0(saturating Maximum \Flow}{
%      \TeamK.setEliminated\leftarrow not eliminated
%      \emph{return not eliminated}
%    }
%    \Else{
%      \Cert\leftarrow team nodes reachable from \Source 
%      \TeamK.setEliminated\leftarrow eliminated
%      \emph{return eliminated}
%    }
%   }
%  \caption{Ford-Fulkerson Algorithm}
%\end{algorithm}
